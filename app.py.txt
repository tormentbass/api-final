# ==============================================================================
# ARQUIVO: app.py
# CONTEÚDO: Definição da API usando FastAPI
# EXECUÇÃO: uvicorn app:app --reload
# ==============================================================================

from fastapi import FastAPI, HTTPException, Query
from pydantic import BaseModel, Field
from typing import List
import engine # Importa todo o seu motor de IA

# --- 1. CONFIGURAÇÃO DA API ---
app = FastAPI(
    title="Análise Esportiva IA",
    description="API de Previsões e Rankings do Motor de IA para Site e Telegram.",
    version="1.0.0"
)

# --- 2. DEFINIÇÃO DOS MODELOS DE DADOS (Pydantic) ---

# Schema para entrada de uma única partida
class MatchInput(BaseModel):
    home_team: str = Field(..., example="Chelsea", description="Nome do time da casa.")
    away_team: str = Field(..., example="Arsenal", description="Nome do time de fora.")
    date: str = Field(..., example="2024-10-25 15:00:00", description="Data e hora da referência para análise histórica.")

# Schema para entrada de múltiplas partidas (Batch)
class BatchInput(BaseModel):
    matches: List[MatchInput]
    date: str = Field(..., example="2024-10-25 15:00:00", description="Data de referência para todos os jogos do lote.")


# --- 3. ENDPOINTS PRINCIPAIS ---

@app.get("/", tags=["Saúde"])
def read_root():
    """Verifica se a API está no ar e se o motor de IA foi carregado."""
    status = "OK" if engine.model is not None else "ERRO - Componentes não carregados"
    return {"api_status": status, "message": "Motor de Análise Esportiva ativo!"}

# --- 3.1. ENDPOINT: Previsão de Partida Única ---

@app.post("/predict/match", tags=["Previsão"])
async def predict_single_match(match: MatchInput):
    """Gera o relatório de previsão completo para uma única partida."""
    try:
        relatorio = engine.gerar_relatorio_json(match.home_team, match.away_team, match.date)
        if relatorio.get("status") == "ERRO":
             raise HTTPException(status_code=404, detail=relatorio.get("mensagem"))
        return relatorio
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro interno do servidor: {str(e)}")

# --- 3.2. ENDPOINT: Previsão em Lote ---

@app.post("/predict/batch", tags=["Previsão"])
async def predict_matches_batch(batch: BatchInput):
    """Gera relatórios de previsão para um lote de partidas."""
    try:
        jogos = [(m.home_team, m.away_team) for m in batch.matches]
        relatorios = engine.predict_batch(jogos, batch.date)
        
        erros = [r for r in relatorios if r.get("status") == "ERRO"]
        
        return {
            "status": "SUCESSO",
            "total_processados": len(relatorios),
            "total_com_erro": len(erros),
            "relatorios": relatorios
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro interno do servidor: {str(e)}")

# --- 3.3. ENDPOINT: Rankings Estatísticos ---

@app.get("/stats/rankings", tags=["Análise Estatística"])
async def get_rankings(date: str = Query(..., example="2024-10-25 15:00:00", description="Data de referência para o ranking.")):
    """Retorna os rankings de Força (Net xG) e Valor (Gols - xG)."""
    try:
        rankings = engine.gerar_ranking_forca(date, num_times=20) 
        if "erro" in rankings:
             raise HTTPException(status_code=404, detail=rankings.get("erro"))
        return rankings
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erro interno do servidor: {str(e)}")